; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\stm32f10x_dma.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\stm32f10x_dma.d --cpu=Cortex-M3 --apcs=interwork -O3 -I.\FWlib\inc -I.\user -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\obj\stm32f10x_dma.crf FWlib\SRC\stm32f10x_dma.c]
                          THUMB

                          AREA ||i.DMA_ClearFlag||, CODE, READONLY, ALIGN=2

                  DMA_ClearFlag PROC
;;;491      */
;;;492    void DMA_ClearFlag(uint32_t DMA_FLAG)
000000  00c1              LSLS     r1,r0,#3
;;;493    {
;;;494      /* Check the parameters */
;;;495      assert_param(IS_DMA_CLEAR_FLAG(DMA_FLAG));
;;;496      /* Calculate the used DMA */
;;;497      if ((DMA_FLAG & FLAG_Mask) != (uint32_t)RESET)
000002  d502              BPL      |L1.10|
;;;498      {
;;;499        /* Clear the selected DMA flags */
;;;500        DMA2->IFCR = DMA_FLAG;
000004  4902              LDR      r1,|L1.16|
000006  6008              STR      r0,[r1,#0]
;;;501      }
;;;502      else
;;;503      {
;;;504        /* Clear the selected DMA flags */
;;;505        DMA1->IFCR = DMA_FLAG;
;;;506      }
;;;507    }
000008  4770              BX       lr
                  |L1.10|
00000a  4902              LDR      r1,|L1.20|
00000c  6048              STR      r0,[r1,#4]            ;505
00000e  4770              BX       lr
;;;508    
                          ENDP

                  |L1.16|
                          DCD      0x40020404
                  |L1.20|
                          DCD      0x40020000

                          AREA ||i.DMA_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  DMA_ClearITPendingBit PROC
;;;650      */
;;;651    void DMA_ClearITPendingBit(uint32_t DMA_IT)
000000  00c1              LSLS     r1,r0,#3
;;;652    {
;;;653      /* Check the parameters */
;;;654      assert_param(IS_DMA_CLEAR_IT(DMA_IT));
;;;655      /* Calculate the used DMA */
;;;656      if ((DMA_IT & FLAG_Mask) != (uint32_t)RESET)
000002  d502              BPL      |L2.10|
;;;657      {
;;;658        /* Clear the selected DMA interrupt pending bits */
;;;659        DMA2->IFCR = DMA_IT;
000004  4902              LDR      r1,|L2.16|
000006  6008              STR      r0,[r1,#0]
;;;660      }
;;;661      else
;;;662      {
;;;663        /* Clear the selected DMA interrupt pending bits */
;;;664        DMA1->IFCR = DMA_IT;
;;;665      }
;;;666    }
000008  4770              BX       lr
                  |L2.10|
00000a  4902              LDR      r1,|L2.20|
00000c  6048              STR      r0,[r1,#4]            ;664
00000e  4770              BX       lr
;;;667    
                          ENDP

                  |L2.16|
                          DCD      0x40020404
                  |L2.20|
                          DCD      0x40020000

                          AREA ||i.DMA_Cmd||, CODE, READONLY, ALIGN=1

                  DMA_Cmd PROC
;;;282      */
;;;283    void DMA_Cmd(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;284    {
;;;285      /* Check the parameters */
;;;286      assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
;;;287      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;288      if (NewState != DISABLE)
;;;289      {
;;;290        /* Enable the selected DMAy Channelx */
;;;291        DMAy_Channelx->CCR |= CCR_ENABLE_Set;
;;;292      }
;;;293      else
;;;294      {
;;;295        /* Disable the selected DMAy Channelx */
;;;296        DMAy_Channelx->CCR &= CCR_ENABLE_Reset;
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L3.12|
000006  f0410101          ORR      r1,r1,#1              ;291
00000a  e001              B        |L3.16|
                  |L3.12|
00000c  f0210101          BIC      r1,r1,#1
                  |L3.16|
000010  6001              STR      r1,[r0,#0]            ;291
;;;297      }
;;;298    }
000012  4770              BX       lr
;;;299    
                          ENDP


                          AREA ||i.DMA_DeInit||, CODE, READONLY, ALIGN=2

                  DMA_DeInit PROC
;;;111      */
;;;112    void DMA_DeInit(DMA_Channel_TypeDef* DMAy_Channelx)
000000  6801              LDR      r1,[r0,#0]
;;;113    {
;;;114      /* Check the parameters */
;;;115      assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
;;;116      /* Disable the selected DMAy Channelx */
;;;117      DMAy_Channelx->CCR &= CCR_ENABLE_Reset;
000002  f0210101          BIC      r1,r1,#1
000006  6001              STR      r1,[r0,#0]
;;;118      /* Reset DMAy Channelx control register */
;;;119      DMAy_Channelx->CCR  = 0;
000008  2100              MOVS     r1,#0
00000a  6001              STR      r1,[r0,#0]
;;;120      
;;;121      /* Reset DMAy Channelx remaining bytes register */
;;;122      DMAy_Channelx->CNDTR = 0;
00000c  6041              STR      r1,[r0,#4]
;;;123      
;;;124      /* Reset DMAy Channelx peripheral address register */
;;;125      DMAy_Channelx->CPAR  = 0;
00000e  6081              STR      r1,[r0,#8]
;;;126      
;;;127      /* Reset DMAy Channelx memory address register */
;;;128      DMAy_Channelx->CMAR = 0;
000010  60c1              STR      r1,[r0,#0xc]
;;;129      switch (*(uint32_t*)&DMAy_Channelx)
000012  4b2d              LDR      r3,|L4.200|
;;;130      {
;;;131        case DMA1_Channel1_BASE:
;;;132          /* Reset interrupt pending bits for DMA1 Channel1 */
;;;133          DMA1->IFCR |= DMA1_Channel1_IT_Mask;
000014  492c              LDR      r1,|L4.200|
000016  1ac2              SUBS     r2,r0,r3              ;129
000018  3980              SUBS     r1,r1,#0x80
00001a  4298              CMP      r0,r3                 ;129
00001c  d043              BEQ      |L4.166|
00001e  dc18              BGT      |L4.82|
000020  4b2a              LDR      r3,|L4.204|
000022  eba00203          SUB      r2,r0,r3              ;129
000026  4298              CMP      r0,r3                 ;129
000028  d035              BEQ      |L4.150|
00002a  dc0a              BGT      |L4.66|
00002c  4a28              LDR      r2,|L4.208|
00002e  1880              ADDS     r0,r0,r2              ;129
000030  d029              BEQ      |L4.134|
000032  2814              CMP      r0,#0x14              ;129
000034  d02b              BEQ      |L4.142|
000036  2828              CMP      r0,#0x28              ;129
000038  d124              BNE      |L4.132|
;;;134          break;
;;;135        case DMA1_Channel2_BASE:
;;;136          /* Reset interrupt pending bits for DMA1 Channel2 */
;;;137          DMA1->IFCR |= DMA1_Channel2_IT_Mask;
;;;138          break;
;;;139        case DMA1_Channel3_BASE:
;;;140          /* Reset interrupt pending bits for DMA1 Channel3 */
;;;141          DMA1->IFCR |= DMA1_Channel3_IT_Mask;
00003a  6848              LDR      r0,[r1,#4]
00003c  f4406070          ORR      r0,r0,#0xf00
;;;142          break;
000040  e034              B        |L4.172|
                  |L4.66|
000042  2a14              CMP      r2,#0x14              ;129
000044  d02b              BEQ      |L4.158|
000046  2a28              CMP      r2,#0x28              ;129
000048  d11c              BNE      |L4.132|
;;;143        case DMA1_Channel4_BASE:
;;;144          /* Reset interrupt pending bits for DMA1 Channel4 */
;;;145          DMA1->IFCR |= DMA1_Channel4_IT_Mask;
;;;146          break;
;;;147        case DMA1_Channel5_BASE:
;;;148          /* Reset interrupt pending bits for DMA1 Channel5 */
;;;149          DMA1->IFCR |= DMA1_Channel5_IT_Mask;
;;;150          break;
;;;151        case DMA1_Channel6_BASE:
;;;152          /* Reset interrupt pending bits for DMA1 Channel6 */
;;;153          DMA1->IFCR |= DMA1_Channel6_IT_Mask;
00004a  6848              LDR      r0,[r1,#4]
00004c  f4400070          ORR      r0,r0,#0xf00000
;;;154          break;
000050  e02c              B        |L4.172|
                  |L4.82|
;;;155        case DMA1_Channel7_BASE:
;;;156          /* Reset interrupt pending bits for DMA1 Channel7 */
;;;157          DMA1->IFCR |= DMA1_Channel7_IT_Mask;
;;;158          break;
;;;159        case DMA2_Channel1_BASE:
;;;160          /* Reset interrupt pending bits for DMA2 Channel1 */
;;;161          DMA2->IFCR |= DMA2_Channel1_IT_Mask;
000052  4820              LDR      r0,|L4.212|
000054  f5b27f6c          CMP      r2,#0x3b0             ;129
000058  d02e              BEQ      |L4.184|
00005a  dc09              BGT      |L4.112|
00005c  f5b27f62          CMP      r2,#0x388             ;129
000060  d026              BEQ      |L4.176|
000062  f5b27f67          CMP      r2,#0x39c             ;129
000066  d10d              BNE      |L4.132|
;;;162          break;
;;;163        case DMA2_Channel2_BASE:
;;;164          /* Reset interrupt pending bits for DMA2 Channel2 */
;;;165          DMA2->IFCR |= DMA2_Channel2_IT_Mask;
000068  6801              LDR      r1,[r0,#0]
00006a  f04101f0          ORR      r1,r1,#0xf0
;;;166          break;
00006e  e008              B        |L4.130|
                  |L4.112|
000070  f5b27f71          CMP      r2,#0x3c4             ;129
000074  d024              BEQ      |L4.192|
000076  f5b27f76          CMP      r2,#0x3d8             ;129
00007a  d103              BNE      |L4.132|
;;;167        case DMA2_Channel3_BASE:
;;;168          /* Reset interrupt pending bits for DMA2 Channel3 */
;;;169          DMA2->IFCR |= DMA2_Channel3_IT_Mask;
;;;170          break;
;;;171        case DMA2_Channel4_BASE:
;;;172          /* Reset interrupt pending bits for DMA2 Channel4 */
;;;173          DMA2->IFCR |= DMA2_Channel4_IT_Mask;
;;;174          break;
;;;175        case DMA2_Channel5_BASE:
;;;176          /* Reset interrupt pending bits for DMA2 Channel5 */
;;;177          DMA2->IFCR |= DMA2_Channel5_IT_Mask;
00007c  6801              LDR      r1,[r0,#0]
00007e  f4412170          ORR      r1,r1,#0xf0000
                  |L4.130|
000082  6001              STR      r1,[r0,#0]
                  |L4.132|
;;;178          break;
;;;179          
;;;180        default:
;;;181          break;
;;;182      }
;;;183    }
000084  4770              BX       lr
                  |L4.134|
000086  6848              LDR      r0,[r1,#4]            ;133
000088  f040000f          ORR      r0,r0,#0xf            ;133
00008c  e00e              B        |L4.172|
                  |L4.142|
00008e  6848              LDR      r0,[r1,#4]            ;137
000090  f04000f0          ORR      r0,r0,#0xf0           ;137
000094  e00a              B        |L4.172|
                  |L4.150|
000096  6848              LDR      r0,[r1,#4]            ;145
000098  f4404070          ORR      r0,r0,#0xf000         ;145
00009c  e006              B        |L4.172|
                  |L4.158|
00009e  6848              LDR      r0,[r1,#4]            ;149
0000a0  f4402070          ORR      r0,r0,#0xf0000        ;149
0000a4  e002              B        |L4.172|
                  |L4.166|
0000a6  6848              LDR      r0,[r1,#4]            ;157
0000a8  f0406070          ORR      r0,r0,#0xf000000      ;157
                  |L4.172|
0000ac  6048              STR      r0,[r1,#4]            ;157
0000ae  4770              BX       lr
                  |L4.176|
0000b0  6801              LDR      r1,[r0,#0]            ;161
0000b2  f041010f          ORR      r1,r1,#0xf            ;161
0000b6  e7e4              B        |L4.130|
                  |L4.184|
0000b8  6801              LDR      r1,[r0,#0]            ;169
0000ba  f4416170          ORR      r1,r1,#0xf00          ;169
0000be  e7e0              B        |L4.130|
                  |L4.192|
0000c0  6801              LDR      r1,[r0,#0]            ;173
0000c2  f4414170          ORR      r1,r1,#0xf000         ;173
0000c6  e7dc              B        |L4.130|
;;;184    
                          ENDP

                  |L4.200|
                          DCD      0x40020080
                  |L4.204|
                          DCD      0x40020044
                  |L4.208|
                          DCD      0xbffdfff8
                  |L4.212|
                          DCD      0x40020404

                          AREA ||i.DMA_GetCurrDataCounter||, CODE, READONLY, ALIGN=1

                  DMA_GetCurrDataCounter PROC
;;;341      */
;;;342    uint16_t DMA_GetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx)
000000  6840              LDR      r0,[r0,#4]
;;;343    {
;;;344      /* Check the parameters */
;;;345      assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
;;;346      /* Return the number of remaining data units for DMAy Channelx */
;;;347      return ((uint16_t)(DMAy_Channelx->CNDTR));
000002  b280              UXTH     r0,r0
;;;348    }
000004  4770              BX       lr
;;;349    
                          ENDP


                          AREA ||i.DMA_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  DMA_GetFlagStatus PROC
;;;403      */
;;;404    FlagStatus DMA_GetFlagStatus(uint32_t DMA_FLAG)
000000  4601              MOV      r1,r0
;;;405    {
;;;406      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
000004  00ca              LSLS     r2,r1,#3
;;;407      uint32_t tmpreg = 0;
;;;408      /* Check the parameters */
;;;409      assert_param(IS_DMA_GET_FLAG(DMA_FLAG));
;;;410      /* Calculate the used DMA */
;;;411      if ((DMA_FLAG & FLAG_Mask) != (uint32_t)RESET)
000006  d501              BPL      |L6.12|
;;;412      {
;;;413        /* Get DMA2 ISR register value */
;;;414        tmpreg = DMA2->ISR ;
000008  4a03              LDR      r2,|L6.24|
00000a  e000              B        |L6.14|
                  |L6.12|
;;;415      }
;;;416      else
;;;417      {
;;;418        /* Get DMA1 ISR register value */
;;;419        tmpreg = DMA1->ISR ;
00000c  4a03              LDR      r2,|L6.28|
                  |L6.14|
00000e  6812              LDR      r2,[r2,#0]
;;;420      }
;;;421      /* Check the status of the specified DMA flag */
;;;422      if ((tmpreg & DMA_FLAG) != (uint32_t)RESET)
000010  420a              TST      r2,r1
000012  d000              BEQ      |L6.22|
;;;423      {
;;;424        /* DMA_FLAG is set */
;;;425        bitstatus = SET;
000014  2001              MOVS     r0,#1
                  |L6.22|
;;;426      }
;;;427      else
;;;428      {
;;;429        /* DMA_FLAG is reset */
;;;430        bitstatus = RESET;
;;;431      }
;;;432      
;;;433      /* Return the DMA_FLAG status */
;;;434      return  bitstatus;
;;;435    }
000016  4770              BX       lr
;;;436    
                          ENDP

                  |L6.24|
                          DCD      0x40020400
                  |L6.28|
                          DCD      0x40020000

                          AREA ||i.DMA_GetITStatus||, CODE, READONLY, ALIGN=2

                  DMA_GetITStatus PROC
;;;563      */
;;;564    ITStatus DMA_GetITStatus(uint32_t DMA_IT)
000000  4601              MOV      r1,r0
;;;565    {
;;;566      ITStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
000004  00ca              LSLS     r2,r1,#3
;;;567      uint32_t tmpreg = 0;
;;;568      /* Check the parameters */
;;;569      assert_param(IS_DMA_GET_IT(DMA_IT));
;;;570      /* Calculate the used DMA */
;;;571      if ((DMA_IT & FLAG_Mask) != (uint32_t)RESET)
000006  d501              BPL      |L7.12|
;;;572      {
;;;573        /* Get DMA2 ISR register value */
;;;574        tmpreg = DMA2->ISR ;
000008  4a03              LDR      r2,|L7.24|
00000a  e000              B        |L7.14|
                  |L7.12|
;;;575      }
;;;576      else
;;;577      {
;;;578        /* Get DMA1 ISR register value */
;;;579        tmpreg = DMA1->ISR ;
00000c  4a03              LDR      r2,|L7.28|
                  |L7.14|
00000e  6812              LDR      r2,[r2,#0]
;;;580      }
;;;581      /* Check the status of the specified DMA interrupt */
;;;582      if ((tmpreg & DMA_IT) != (uint32_t)RESET)
000010  420a              TST      r2,r1
000012  d000              BEQ      |L7.22|
;;;583      {
;;;584        /* DMA_IT is set */
;;;585        bitstatus = SET;
000014  2001              MOVS     r0,#1
                  |L7.22|
;;;586      }
;;;587      else
;;;588      {
;;;589        /* DMA_IT is reset */
;;;590        bitstatus = RESET;
;;;591      }
;;;592      /* Return the DMA_IT status */
;;;593      return  bitstatus;
;;;594    }
000016  4770              BX       lr
;;;595    
                          ENDP

                  |L7.24|
                          DCD      0x40020400
                  |L7.28|
                          DCD      0x40020000

                          AREA ||i.DMA_ITConfig||, CODE, READONLY, ALIGN=1

                  DMA_ITConfig PROC
;;;314      */
;;;315    void DMA_ITConfig(DMA_Channel_TypeDef* DMAy_Channelx, uint32_t DMA_IT, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;316    {
;;;317      /* Check the parameters */
;;;318      assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
;;;319      assert_param(IS_DMA_CONFIG_IT(DMA_IT));
;;;320      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;321      if (NewState != DISABLE)
;;;322      {
;;;323        /* Enable the selected DMA interrupts */
;;;324        DMAy_Channelx->CCR |= DMA_IT;
;;;325      }
;;;326      else
;;;327      {
;;;328        /* Disable the selected DMA interrupts */
;;;329        DMAy_Channelx->CCR &= ~DMA_IT;
000002  6802              LDR      r2,[r0,#0]
000004  d001              BEQ      |L8.10|
000006  430a              ORRS     r2,r2,r1              ;324
000008  e000              B        |L8.12|
                  |L8.10|
00000a  438a              BICS     r2,r2,r1
                  |L8.12|
00000c  6002              STR      r2,[r0,#0]            ;324
;;;330      }
;;;331    }
00000e  4770              BX       lr
;;;332    
                          ENDP


                          AREA ||i.DMA_Init||, CODE, READONLY, ALIGN=1

                  DMA_Init PROC
;;;195      */
;;;196    void DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;197    {
;;;198      uint32_t tmpreg = 0;
;;;199      /* Check the parameters */
;;;200      assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
;;;201      assert_param(IS_DMA_DIR(DMA_InitStruct->DMA_DIR));
;;;202      assert_param(IS_DMA_BUFFER_SIZE(DMA_InitStruct->DMA_BufferSize));
;;;203      assert_param(IS_DMA_PERIPHERAL_INC_STATE(DMA_InitStruct->DMA_PeripheralInc));
;;;204      assert_param(IS_DMA_MEMORY_INC_STATE(DMA_InitStruct->DMA_MemoryInc));   
;;;205      assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(DMA_InitStruct->DMA_PeripheralDataSize));
;;;206      assert_param(IS_DMA_MEMORY_DATA_SIZE(DMA_InitStruct->DMA_MemoryDataSize));
;;;207      assert_param(IS_DMA_MODE(DMA_InitStruct->DMA_Mode));
;;;208      assert_param(IS_DMA_PRIORITY(DMA_InitStruct->DMA_Priority));
;;;209      assert_param(IS_DMA_M2M_STATE(DMA_InitStruct->DMA_M2M));
;;;210    /*--------------------------- DMAy Channelx CCR Configuration -----------------*/
;;;211      /* Get the DMAy_Channelx CCR value */
;;;212      tmpreg = DMAy_Channelx->CCR;
000002  6803              LDR      r3,[r0,#0]
;;;213      /* Clear MEM2MEM, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
;;;214      tmpreg &= CCR_CLEAR_Mask;
000004  f64772f0          MOV      r2,#0x7ff0
000008  4393              BICS     r3,r3,r2
;;;215      /* Configure DMAy Channelx: data transfer, data size, priority level and mode */
;;;216      /* Set DIR bit according to DMA_DIR value */
;;;217      /* Set CIRC bit according to DMA_Mode value */
;;;218      /* Set PINC bit according to DMA_PeripheralInc value */
;;;219      /* Set MINC bit according to DMA_MemoryInc value */
;;;220      /* Set PSIZE bits according to DMA_PeripheralDataSize value */
;;;221      /* Set MSIZE bits according to DMA_MemoryDataSize value */
;;;222      /* Set PL bits according to DMA_Priority value */
;;;223      /* Set the MEM2MEM bit according to DMA_M2M value */
;;;224      tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
00000a  6a0c              LDR      r4,[r1,#0x20]
00000c  688a              LDR      r2,[r1,#8]
00000e  4322              ORRS     r2,r2,r4
000010  e9d14504          LDRD     r4,r5,[r1,#0x10]
000014  432c              ORRS     r4,r4,r5
000016  4322              ORRS     r2,r2,r4
000018  698c              LDR      r4,[r1,#0x18]
00001a  4322              ORRS     r2,r2,r4
00001c  69cc              LDR      r4,[r1,#0x1c]
00001e  4322              ORRS     r2,r2,r4
000020  6a4c              LDR      r4,[r1,#0x24]
000022  4322              ORRS     r2,r2,r4
000024  6a8c              LDR      r4,[r1,#0x28]
000026  4322              ORRS     r2,r2,r4
000028  431a              ORRS     r2,r2,r3
;;;225                DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
;;;226                DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
;;;227                DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;
;;;228      /* Write to DMAy Channelx CCR */
;;;229      DMAy_Channelx->CCR = tmpreg;
00002a  6002              STR      r2,[r0,#0]
;;;230    /*--------------------------- DMAy Channelx CNDTR Configuration ---------------*/
;;;231      /* Write to DMAy Channelx CNDTR */
;;;232      DMAy_Channelx->CNDTR = DMA_InitStruct->DMA_BufferSize;
00002c  68ca              LDR      r2,[r1,#0xc]
00002e  6042              STR      r2,[r0,#4]
;;;233    /*--------------------------- DMAy Channelx CPAR Configuration ----------------*/
;;;234      /* Write to DMAy Channelx CPAR */
;;;235      DMAy_Channelx->CPAR = DMA_InitStruct->DMA_PeripheralBaseAddr;
000030  680a              LDR      r2,[r1,#0]
000032  6082              STR      r2,[r0,#8]
;;;236    /*--------------------------- DMAy Channelx CMAR Configuration ----------------*/
;;;237      /* Write to DMAy Channelx CMAR */
;;;238      DMAy_Channelx->CMAR = DMA_InitStruct->DMA_MemoryBaseAddr;
000034  6849              LDR      r1,[r1,#4]
000036  60c1              STR      r1,[r0,#0xc]
;;;239    }
000038  bd30              POP      {r4,r5,pc}
;;;240    
                          ENDP


                          AREA ||i.DMA_StructInit||, CODE, READONLY, ALIGN=1

                  DMA_StructInit PROC
;;;246      */
;;;247    void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct)
000000  2100              MOVS     r1,#0
;;;248    {
;;;249    /*-------------- Reset DMA init structure parameters values ------------------*/
;;;250      /* Initialize the DMA_PeripheralBaseAddr member */
;;;251      DMA_InitStruct->DMA_PeripheralBaseAddr = 0;
;;;252      /* Initialize the DMA_MemoryBaseAddr member */
;;;253      DMA_InitStruct->DMA_MemoryBaseAddr = 0;
000002  6001              STR      r1,[r0,#0]
;;;254      /* Initialize the DMA_DIR member */
;;;255      DMA_InitStruct->DMA_DIR = DMA_DIR_PeripheralSRC;
000004  6041              STR      r1,[r0,#4]
;;;256      /* Initialize the DMA_BufferSize member */
;;;257      DMA_InitStruct->DMA_BufferSize = 0;
000006  6081              STR      r1,[r0,#8]
;;;258      /* Initialize the DMA_PeripheralInc member */
;;;259      DMA_InitStruct->DMA_PeripheralInc = DMA_PeripheralInc_Disable;
000008  60c1              STR      r1,[r0,#0xc]
;;;260      /* Initialize the DMA_MemoryInc member */
;;;261      DMA_InitStruct->DMA_MemoryInc = DMA_MemoryInc_Disable;
00000a  6101              STR      r1,[r0,#0x10]
;;;262      /* Initialize the DMA_PeripheralDataSize member */
;;;263      DMA_InitStruct->DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
00000c  6141              STR      r1,[r0,#0x14]
;;;264      /* Initialize the DMA_MemoryDataSize member */
;;;265      DMA_InitStruct->DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
00000e  6181              STR      r1,[r0,#0x18]
;;;266      /* Initialize the DMA_Mode member */
;;;267      DMA_InitStruct->DMA_Mode = DMA_Mode_Normal;
000010  61c1              STR      r1,[r0,#0x1c]
;;;268      /* Initialize the DMA_Priority member */
;;;269      DMA_InitStruct->DMA_Priority = DMA_Priority_Low;
000012  6201              STR      r1,[r0,#0x20]
;;;270      /* Initialize the DMA_M2M member */
;;;271      DMA_InitStruct->DMA_M2M = DMA_M2M_Disable;
000014  6241              STR      r1,[r0,#0x24]
000016  6281              STR      r1,[r0,#0x28]
;;;272    }
000018  4770              BX       lr
;;;273    
                          ENDP

